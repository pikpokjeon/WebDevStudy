<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

<script>
//참조에 의한 호출과  값에 의한 호출
function add(z){
  z.x=z.y+1; 
  z.y=z.x+1;
  return z;

}
const ltr = {x:0, y:1};
const cat = add(ltr);
console.log(ltr,cat);

//인수 여러 개를 우아하게 전달하기

const things = {
  _1 : 1,
  _2 : 2,
  _3 : 3
};
function makeAThing (e){
 return  e._1+e._2+e._3;
}
const done = makeAThing(things);
console.log(done);

//생성자로 객체 생성하기
//내장 생성자들도 앞머리 다 대문자!!!!! 관례적으로 그러는거지만 
//내가 만든 생성자는 실제로 소문자로 적어도 됨
function Card(suit , rank){
  this.suit = suit; //this 는 참조하는 객체를 의미한다
  this.rank = rank;
};

const card = new Card('Heart','A');
//객체를 출력해 보면, 앞에 생성자 이름이 표시됨
console.log(card);

//메서드를 가진 객체를 생성하기
function Circle(center, radius){
  this.center = center;
  this.radius = radius;
  this.area =()=>{ 
    //this 를 사용하면 그 값이 인스턴스의 프로퍼티임을 명시
    return Math.PI * this.radius * this.radius;
  };
}
const p = {x:2, y:4};
const circle = new Circle(p, 4.0);
console.log("넓이:"+circle.area());

//function 생성자
let x = 1;
const square = new Function( 'return x+x');

//첫번째 인자는 인수의 이름을 나타내는 문자열, 두번째 인수는 함수의 body 문자열
//new Function(인수이름,함수몸통,..,..) 차례로 n개 열거
const square2 = new Function('x', 'return x+x');

//함수생성자의 단점은??몰까->악성스크립트 해킹문제

//함수생성자 장점?? 함수리터럴에 래퍼객체(???) 제공

//내장객체 (built in Object) 처음부터 사용가능한 객체
//내장생성자가 내장객체를 만든다.

//내장 생성자가 생성하지 않는 객체들
//전역객체 :프로그램 어디서나 사용할 수 있는 객체
//JSON
//Math :수학적인 함수와 상수를 제공
//Reflect :프로그램의 흐름을 가로채는 기능을 제공<-----------??

//전역객체 : 의 프로퍼티는 프로그램의 어디서나 사용가능,
//          JS인터프리터의 실행이나 웹브라우저 새로 읽을 때 생성됨.
//      -> Window, 
console.dir(window); //모든 프로퍼티 확인하기





//배열
//자바스크립트의 배열은  Array 내부객체인데 객체로 배열기능을 흉내내는 것.
// Array 객체는 인덱스를 문자열로 변환해서 인덱스를 프로퍼티로 사용.

const empty = []; //빈 배열
const aEmpty = [2, , 5];
console.log(aEmpty); 
//=> [2, undefind , 5] 2번째 인덱스에 요소 없음, 생성되지 않음 그래도 위치해있음!

//배열.length 프로퍼티
// 배열길이는 배열 요소의 '최대 인덱스 값' +1
const arrray = [1,2,3,4]; // 인덱스 0 ,1 ,2, 3 

//배열 요소의 갯수가 길이를 뜻하는 언어는 JAVA. C 하지만 자바스크립트에서는
//항상 뜻하지 않아서 조심해야됨.
console.log(arrray);
console.log(arrray.length);// = 4


//현재 길이보다 작고 0보다 큰 숫자값을 길이에 대입하면 그만큼 줄어듬
//뒤에서 부터 삭제
console.log(arrray.length=3)
console.log('arrray.length=3',arrray);

//배열길이보다 큰 숫자값을 대입하면 
//실제 요소가 추가되는게 아니고 길이 프로퍼티 값만 바뀜, 그리고 빈 공간생김
arrray.length=4;
console.log('arrray.length=4;',arrray);

//자바스크립트에는 튜플 {ㅇ,ㄹ,ㄴ}이 없다
let arr1 = new Array('인자 값들',true,+43,-11,{'a':1,'b':2},'타입에 상관x다 들어감',);
console.log('배열길이:'+arr1.length,arr1);


//확인사살

console.log('arr1.length=5 는->',arr1.length=5,'배열요소->',arr1)
//배열 인수가 양의 정수이고 한개면? 인수는 배열의 길이를 의미하게 됨

//한개요소를 가지는 배열 만들어보기 
const only = new Array(2222,); 
//(실패) 배열길이가 2222개인 empty요소들만 채워진 배열 앞뒤 empty도 못 넣어줌
console.log('new Array(2222 ,)->',only);


arr2 = new Array('인자 값들',true,+43,-11,{'a':1,'b':2});

//그래서 그 인수 만큼 배열요소가 생성됨
arr2 = new Array(5);
console.log(' new Array(5);길이->'+arr1.length,'배열요소->',arr1);


//반대로 음의 정수이고 한개의 인수를 가진다면 => 오류발생 
//const arr2 = new Array(-1);

//배열요소의 참조
console.log('[3] -> ',arr1[3]);  //-11
console.log('typeof(arr1[3])->',typeof(arr1[3])); //number 인덱스 (프로퍼티)

console.log('["3"] -> ',arr1[3]);  //-11
console.log('typeof(arr1["3"])->',typeof(arr1["3"])); //number?! 인덱스 (프로퍼티)

//베열 추가
const arry = ['a',1,-4,[1,2,3],{1:1,2:2}]; // 길이는 4
console.log('arry elements=>',arry);
console.log('arry length=>',arry.length);
// arry[6] = 999;
// console.log('arry elements added  a value "999" in the property [6] = 999=>',arry);
// console.log('arry length=>',arry.length);

//배열 추가
// push 매서드를 사용하면 배열끝에 요소를 추가함!
arry.push('---');
console.log('arry elements=>',arry);
//동적으로 array요소 길이가 변경되었기 때문에 push 전엔 기존 길이가 나오고
//구글 익스텐션으로 길이를 보면 배열길이는 이미 변경되었음
console.log('arry length=>',arry.length);

delete arry[0];
console.log('arry elements=>',arry);
console.log('arry length=>',arry.length);



//TypedArray 
//새로 추가된 객체인데 이 배열의 요소는 C 배열처럼 
// 메모리의 연속된 공간에 차례대로 배치.






</script>  
</body>
</html>